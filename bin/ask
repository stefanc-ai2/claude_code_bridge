#!/usr/bin/env python3
"""
ask - Unified command to send messages to different AI providers.

Usage:
    ask <provider> [options] <message>

Providers:
    gemini, codex, opencode, droid, claude

Modes:
    Default (async):  Background task with hook callback
    --notify:         Sync send, no wait for reply (for notifications)
    --foreground:     Run in foreground (no nohup/background)
    --background:     Force background mode

Examples:
    ask gemini "12+12=?"
    ask claude --notify --no-wrap "Task completed"
"""

from __future__ import annotations

import os
import subprocess
import sys
import tempfile
from datetime import datetime
from pathlib import Path

PROVIDER_DISPLAY = {
    "opencode": "OpenCode",
}


def display_name(provider: str) -> str:
    return PROVIDER_DISPLAY.get(provider, provider.capitalize())

script_dir = Path(__file__).resolve().parent
lib_dir = script_dir.parent / "lib"
sys.path.insert(0, str(lib_dir))

from compat import read_stdin_text, setup_windows_encoding
setup_windows_encoding()

from cli_output import EXIT_ERROR, EXIT_OK


# Provider to daemon command mapping
PROVIDER_DAEMONS = {
    "gemini": "gask",
    "codex": "cask",
    "opencode": "oask",
    "droid": "dask",
    "claude": "lask",
}


def _env_int(name: str, default: int) -> int:
    raw = (os.environ.get(name) or "").strip()
    if not raw:
        return default
    try:
        return int(raw)
    except Exception:
        return default


def _cleanup_task_logs(log_dir: Path) -> None:
    """Keep latest task logs under log_dir."""
    max_files = _env_int("CCB_TASK_LOG_MAX_FILES", 100)
    if max_files <= 0:
        return
    try:
        logs = list(log_dir.glob("ask-*.log"))
    except Exception:
        return
    if len(logs) <= max_files:
        return
    try:
        logs.sort(key=lambda p: p.stat().st_mtime, reverse=True)
    except Exception:
        logs.sort(key=lambda p: p.name, reverse=True)
    for path in logs[max_files:]:
        prefix = path.name[:-4]  # strip .log
        for ext in (".log", ".sh", ".ps1", ".msg"):
            try:
                (log_dir / f"{prefix}{ext}").unlink(missing_ok=True)
            except Exception:
                pass


def _use_unified_daemon() -> bool:
    """Check if unified askd daemon should be used (default: True)."""
    val = (os.environ.get("CCB_UNIFIED_ASKD") or "").strip().lower()
    if val in ("0", "false", "no", "off"):
        return False
    return True  # Default to unified daemon


def _send_via_unified_daemon(
    provider: str,
    message: str,
    timeout: float,
    no_wrap: bool,
    caller: str,
) -> int:
    """Send request via unified askd daemon."""
    import json
    import socket

    from askd_runtime import state_file_path
    import askd_rpc

    # Use CCB_RUN_DIR (set by CCB startup) to locate the state file.
    # This already contains the correct project-specific path.
    state_file = state_file_path("askd.json")

    state = askd_rpc.read_state(state_file)
    if not state:
        print("[ERROR] Unified askd daemon not running", file=sys.stderr)
        return EXIT_ERROR

    host = state.get("connect_host") or state.get("host") or "127.0.0.1"
    port = int(state.get("port") or 0)
    token = state.get("token") or ""
    # Use daemon's work_dir instead of current shell's cwd
    raw_work_dir = state.get("work_dir")
    daemon_work_dir = raw_work_dir.strip() if isinstance(raw_work_dir, str) and raw_work_dir.strip() else ""
    if not daemon_work_dir or not Path(daemon_work_dir).is_dir():
        if daemon_work_dir:
            print(f"[WARN] daemon work_dir not found: {daemon_work_dir}, falling back to cwd", file=sys.stderr)
        daemon_work_dir = os.getcwd()

    if not port:
        print("[ERROR] Invalid askd state", file=sys.stderr)
        return EXIT_ERROR

    req = {
        "type": "ask.request",
        "v": 1,
        "id": make_task_id(),
        "token": token,
        "provider": provider,
        "work_dir": daemon_work_dir,
        "timeout_s": timeout,
        "message": message,
        "no_wrap": no_wrap,
        "caller": caller,
    }

    # Pass email-related env vars for email caller
    if caller == "email":
        req["email_req_id"] = os.environ.get("CCB_EMAIL_REQ_ID", "")
        req["email_msg_id"] = os.environ.get("CCB_EMAIL_MSG_ID", "")
        req["email_from"] = os.environ.get("CCB_EMAIL_FROM", "")

    try:
        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        sock.settimeout(timeout + 10 if timeout > 0 else 3610)
        sock.connect((host, port))
        sock.sendall((json.dumps(req) + "\n").encode("utf-8"))

        data = b""
        while True:
            chunk = sock.recv(4096)
            if not chunk:
                break
            data += chunk
            if b"\n" in data:
                break

        sock.close()
        resp = json.loads(data.decode("utf-8").strip())
        exit_code = int(resp.get("exit_code") or 0)
        reply = resp.get("reply") or ""
        if reply:
            print(reply)
        return exit_code
    except Exception as e:
        print(f"[ERROR] {e}", file=sys.stderr)
        return EXIT_ERROR


def _env_bool(name: str, default: bool = False) -> bool:
    val = (os.environ.get(name) or "").strip().lower()
    if not val:
        return default
    return val not in ("0", "false", "no", "off")


def _default_foreground() -> bool:
    # Allow explicit override
    if _env_bool("CCB_ASK_BACKGROUND", False):
        return False
    if _env_bool("CCB_ASK_FOREGROUND", False):
        return True
    # If CCB_CALLER is set, use background (nohup) mode
    if os.environ.get("CCB_CALLER"):
        return False
    # No caller set, use foreground mode
    return True


def _require_caller() -> str:
    caller = (os.environ.get("CCB_CALLER") or "").strip()
    if caller:
        return caller
    print("[ERROR] CCB_CALLER is required. Set CCB_CALLER=<provider> (e.g. CCB_CALLER=claude).", file=sys.stderr)
    sys.exit(1)


def make_task_id() -> str:
    """Generate task ID: YYYYMMDD-HHMMSS-mmm-PID"""
    now = datetime.now()
    ms = now.microsecond // 1000
    return f"{now.strftime('%Y%m%d-%H%M%S')}-{ms:03d}-{os.getpid()}"


def _usage() -> None:
    print("Usage: ask <provider> [options] <message>", file=sys.stderr)
    print("", file=sys.stderr)
    print("Providers:", file=sys.stderr)
    print("  gemini, codex, opencode, droid, claude", file=sys.stderr)
    print("", file=sys.stderr)
    print("Options:", file=sys.stderr)
    print("  -h, --help              Show this help message", file=sys.stderr)
    print("  -t, --timeout SECONDS   Request timeout (default: 3600)", file=sys.stderr)
    print("  --notify                Sync send, no wait for reply (for notifications)", file=sys.stderr)
    print("  --foreground            Run in foreground (no nohup/background)", file=sys.stderr)
    print("  --background            Force background mode", file=sys.stderr)
    print("  --no-wrap               Don't wrap with CCB protocol markers", file=sys.stderr)


def main(argv: list[str]) -> int:
    if len(argv) <= 1:
        _usage()
        return EXIT_ERROR

    # First argument must be the provider
    provider = argv[1].lower()

    if provider in ("-h", "--help"):
        _usage()
        return EXIT_OK

    if provider not in PROVIDER_DAEMONS:
        print(f"[ERROR] Unknown provider: {provider}", file=sys.stderr)
        print(f"[ERROR] Available: {', '.join(PROVIDER_DAEMONS.keys())}", file=sys.stderr)
        return EXIT_ERROR

    daemon_cmd = PROVIDER_DAEMONS[provider]

    # Parse remaining arguments
    timeout: float = 3600.0
    notify_mode = False
    no_wrap = False
    foreground_mode = _default_foreground()
    parts: list[str] = []

    it = iter(argv[2:])
    for token in it:
        if token in ("-h", "--help"):
            _usage()
            return EXIT_OK
        if token in ("-t", "--timeout"):
            try:
                timeout = float(next(it))
            except StopIteration:
                print("[ERROR] --timeout requires a number", file=sys.stderr)
                return EXIT_ERROR
            except ValueError:
                print("[ERROR] --timeout must be a number", file=sys.stderr)
                return EXIT_ERROR
            continue
        if token == "--notify":
            notify_mode = True
            continue
        if token == "--foreground":
            foreground_mode = True
            continue
        if token == "--background":
            foreground_mode = False
            continue
        if token == "--no-wrap":
            no_wrap = True
            continue
        parts.append(token)

    message = " ".join(parts).strip()
    if not message and not sys.stdin.isatty():
        message = read_stdin_text().strip()
    if not message:
        print("[ERROR] Message cannot be empty", file=sys.stderr)
        return EXIT_ERROR

    # Use unified daemon if enabled (CCB_UNIFIED_ASKD=1)
    if _use_unified_daemon() and foreground_mode:
        caller = _require_caller()
        return _send_via_unified_daemon(provider, message, timeout, no_wrap, caller)

    # Notify mode: sync send, no wait for reply (used for hook notifications)
    if notify_mode:
        _require_caller()
        cmd = [daemon_cmd, "--sync"]
        if no_wrap:
            cmd.append("--no-wrap")
        try:
            result = subprocess.run(
                cmd,
                input=message,
                capture_output=True,
                text=True,
                timeout=10
            )
            return result.returncode
        except subprocess.TimeoutExpired:
            return EXIT_OK
        except Exception as e:
            print(f"[ERROR] {e}", file=sys.stderr)
            return EXIT_ERROR

    # Foreground mode: run provider directly (avoid background cleanup in managed envs)
    if foreground_mode:
        cmd = [daemon_cmd, "--sync", "--timeout", str(timeout)]
        if no_wrap and provider == "claude":
            cmd.append("--no-wrap")
        env = os.environ.copy()
        env["CCB_CALLER"] = _require_caller()
        try:
            result = subprocess.run(cmd, input=message, text=True, env=env)
            return result.returncode
        except Exception as e:
            print(f"[ERROR] {e}", file=sys.stderr)
            return EXIT_ERROR

    # Default async mode: background task via nohup, using unified askd daemon
    task_id = make_task_id()
    log_dir = Path(tempfile.gettempdir()) / "ccb-tasks"
    log_dir.mkdir(parents=True, exist_ok=True)
    log_file = log_dir / f"ask-{provider}-{task_id}.log"
    try:
        log_file.touch(exist_ok=True)
    except Exception:
        pass
    _cleanup_task_logs(log_dir)

    # Detect caller from environment or default to "claude"
    caller = _require_caller()

    # Get the path to this script for recursive call with --foreground
    ask_cmd = str(Path(__file__).resolve())

    # Platform-specific background execution
    if os.name == "nt":
        # Windows: use PowerShell script
        DETACHED_PROCESS = 0x00000008
        CREATE_NO_WINDOW = 0x08000000
        CREATE_NEW_PROCESS_GROUP = 0x00000200

        # Write message to temp file to avoid escaping issues
        msg_file = log_dir / f"ask-{provider}-{task_id}.msg"
        msg_file.write_text(message, encoding="utf-8")

        # Write PowerShell script - call ask --foreground to use unified daemon
        script_file = log_dir / f"ask-{provider}-{task_id}.ps1"
        script_content = f'''$ErrorActionPreference = "SilentlyContinue"
[Console]::OutputEncoding = [System.Text.Encoding]::UTF8
$env:CCB_REQ_ID = "{task_id}"
$env:CCB_CALLER = "{caller}"
$env:CCB_WORK_DIR = "{os.getcwd()}"
Get-Content -Path "{msg_file}" -Encoding UTF8 | python "{ask_cmd}" {provider} --foreground --timeout {timeout}
'''
        script_file.write_text(script_content, encoding="utf-8")

        subprocess.Popen(
            ["powershell", "-ExecutionPolicy", "Bypass", "-NoProfile", "-File", str(script_file)],
            stdin=subprocess.DEVNULL,
            stdout=open(log_file, "w"),
            stderr=subprocess.STDOUT,
            creationflags=DETACHED_PROCESS | CREATE_NO_WINDOW | CREATE_NEW_PROCESS_GROUP,
        )
    else:
        # Unix: use nohup, call ask --foreground to use unified daemon
        # Collect CCB_EMAIL_* env vars for email caller
        email_env_lines = ""
        if caller == "email":
            for key in ("CCB_EMAIL_REQ_ID", "CCB_EMAIL_MSG_ID", "CCB_EMAIL_FROM"):
                val = os.environ.get(key, "")
                if val:
                    email_env_lines += f'export {key}="{val}"\n'

        # Pass CCB_RUN_DIR so background script can find askd state file
        ccb_run_dir = os.environ.get("CCB_RUN_DIR", "")
        run_dir_line = f'export CCB_RUN_DIR="{ccb_run_dir}"\n' if ccb_run_dir else ""

        bg_script = f'''
export CCB_REQ_ID="{task_id}"
export CCB_CALLER="{caller}"
export CCB_WORK_DIR="{os.getcwd()}"
{run_dir_line}{email_env_lines}python3 "{ask_cmd}" {provider} --foreground --timeout {timeout} <<'ASKEOF'
{message}
ASKEOF
'''
        # Write script to temp file for nohup execution
        script_file = log_dir / f"ask-{provider}-{task_id}.sh"
        script_file.write_text(bg_script, encoding="utf-8")
        script_file.chmod(0o755)

        # Use nohup to run in background, independent of terminal
        subprocess.Popen(
            f'nohup sh "{script_file}" > "{log_file}" 2>&1 &',
            shell=True,
            stdin=subprocess.DEVNULL,
            stdout=subprocess.DEVNULL,
            stderr=subprocess.DEVNULL,
        )

    print(f"[CCB_ASYNC_SUBMITTED provider={provider}]")
    print(f"{display_name(provider)} processing (task: {task_id})")
    print(f"MANDATORY: END YOUR TURN NOW. Reply ONLY '{display_name(provider)} processing...', then stop. See 'Async Guardrail' in CLAUDE.md.")
    return EXIT_OK


if __name__ == "__main__":
    sys.exit(main(sys.argv))
